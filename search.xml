<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>节流与防抖</title>
      <link href="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
      <url>/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<p>因为要做一个记忆翻牌配对小游戏，然后在学习时偶然看到“节流”二字，然后就顺便去看了看所谓的“节流”</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><h5 id="1-啥是节流"><a href="#1-啥是节流" class="headerlink" title="1.啥是节流"></a>1.啥是节流</h5><p> n 秒内只执行一次事件，即使n 秒内事件重复触发，也只有一次生效。</p><p>如果这不好理解，那就假设一个场景：</p><p>1.你设计了一个表单，这个表单提交的数据内容很多。</p><p>2.你的有些用户闲得很无聊，写完表单以后疯狂点击提交按钮。</p><p>3.你的后端同事走到你面前指着崩溃的服务器来向你抱怨。</p><p>这就像打游戏放技能一样，放完一次技能后就有一段的冷却时间</p><p><strong>所以我的第一想法肯定是给这个button一个冷却时间</strong></p><p>现在在我面前的有两个东西：一个按钮提交的功能，一个冷却时间，假设为5秒</p><p>牵扯到时间会让我第一时间想到 setTimeout和setInterval，首先排除setInterval，因为提交表单这个功能我不希望它循环执行，所以我选择setTimeout。</p><p>假设你现在正在玩游戏，游戏有一个技能，它的技能CD是两秒，那么我们就需要判断用户是否在两秒内多处点击了这个技能，如果多次点击，那么无事发生(返回一个空函数)，如果不在CD，那么返回这个技能的特效(技能执行的函数)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fnOnclick</span> = (<span class="params"></span>)=&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;技能已经开启！&quot;</span>)</span><br><span class="line">&lt;button onClick =&#123;<span class="title function_">cdTime</span>(fnOnclick,<span class="number">2000</span>)&#125;&gt;技能&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>在这里我们需要知道cdTime这个函数只是一个外壳函数，它真正的意义在于传递我们需要的参数，它并不是我们希望onclick真正要执行的函数！cdTime返回的那个函数才是我们真正想执行的函数</p><p>现在我们设计cdTime，也就是我们限制 技能 只能在两秒之内释放。</p><h5 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn0nClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>. <span class="title function_">log</span>(<span class="string">&quot;技能已经开启!!&quot;</span>) </span><br><span class="line"><span class="comment">//这就是你按钮提交的onclick事件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cdTime</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">CD</span> =<span class="literal">false</span>; <span class="comment">//首先你的技能刚开始是没有冷却时间的</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">CD</span>) &#123;  <span class="comment">//ok, 当你想放技能的时候，你需要判断是否在冷却时间内，如果在，对不起不能放!</span></span><br><span class="line">   <span class="variable language_">console</span>. log (<span class="string">&quot;不行，cd中&quot;</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//这里写null, 空值都可以</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="variable constant_">CD</span> = <span class="literal">true</span>; <span class="comment">//这步我的技能还没放，即将要释放。因为setTimout是异步执行， 所以cd在两秒以后才会被修改，这一步是限制用户频繁点击技能键时，让函数返回一个空值。</span></span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">       <span class="comment">//现在没有进入cd,当你放技能的时候然后开始启用</span></span><br><span class="line">    <span class="variable language_">console</span>. <span class="title function_">log</span>(<span class="string">&quot;技能成功释放&quot;</span>);</span><br><span class="line">    <span class="variable constant_">CD</span> = <span class="literal">false</span>; <span class="comment">//ok, 现在我技能释放完毕，把cd的属性清空。</span></span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">   &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我在看完节流后又摸过去看了看防抖</p><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><h5 id="1-啥是防抖"><a href="#1-啥是防抖" class="headerlink" title="1.啥是防抖"></a>1.啥是防抖</h5><p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p><p>我们拿一个点击按钮来举例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSearch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发请求&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick =<span class="function">()=&gt;</span>&#123;getSearch&#125;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>现在我们尝试疯狂点击按钮就会疯狂发送请求。</p><p><img src="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/9543abdb5ca263fa9cfed8249da1b80b-17106463660994.gif" alt="img"></p><p>我们现在来修改一下这个函数，我们思考一下🤔，假设我们不借助 debounce 可以实现一个伪防抖的功能吗？答案是百分百可以的。我们先在这个文件下设定一个变量叫做 timerID</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后我们设定一个定时器，来使这个 console.log(“发请求”) 在 1.5s 后执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSearch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发请求&quot;</span>)</span><br><span class="line">    &#125;，<span class="number">1500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里要补充讲一下：setTimeout的返回值</p><p><img src="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/a7d724e8e4fe5bad655770af094f890b-17106466934338.png" alt="img"><img src="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/64a7ccad3cf4d06288bdb410b4ee2ef1-171064671466610.png" alt="img"></p><p>其实 setTimeout 会在 setTimeout 执行的时候返回一个大于 0 的正整数。 所以我们这句话其实是在给 timerID 赋值！ 并不是将 setTimeout 函数本身赋值给 timerID 这个变量。</p><p><img src="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/00460f1829b92ec0e0e717e7b04be3ce-171064675808712.png" alt="img"></p><p>这里我们需要特别搞清楚 setTimout函数本身执行的时候，是马上赋值的，并不是等到 1.5s 后再赋值的。什么意思呢？ 我设置了大约在10几年后再执行的一个函数，千万不要觉得 timerID 是会在10年以后才会被赋值。</p><p>为什么要这样设计呢？因为如果这样执行的话，就会给我们一个反悔的机会。还说上面的例子。假设我在 5 年后突然反悔不想执行了。我只需要取消这个 timerID 就可以中途放弃执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cancelSearch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我取消的ID是&quot;</span>，timerId)</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 timerID 就是每一个 setTimeout 的身份证。每当你执行一次 setTimout 后，setTimout 所接收的回调函数就会被分配一个唯一 ID，来被放进任务队列。 而 clearTimeout 的功能恰好就是清除位于任务队列里指定的 id 所绑定的那个回调函数。</p><h5 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSearch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timerId)&#123;</span><br><span class="line">        <span class="title function_">clreaTimeout</span>(timerId)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当我们每次执行 getSearch 之前，如果当前任务队列里有上一次同样的任务，我们就先清除掉</span></span><br><span class="line">    </span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发请求&quot;</span>)</span><br><span class="line">    &#125;，<span class="number">1200</span>)</span><br><span class="line">    <span class="comment">//然后再去开启一个定时器任务推进任务队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React实现图片懒加载</title>
      <link href="/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>图片懒加载是一种优化网页性能的技术，它允许在用户滚动到图片位置之前延迟加载图片。通过懒加载，可以在用户需要查看图片时才加载图片，避免了不必要的图片加载，从而提高了网页的加载速度和用户体验。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>在说明思路之前，先了解几个常见的视图属性。</p><ol><li><p><strong>clientHeight</strong>：元素的像素高度,包含元素的高度+内边距,不包含水平滚动条,边框和外边距。</p></li><li><p><strong>scrollTop</strong>：滚动条滚动的高度，它指的是内容区的顶部到可视区域顶部的距离。</p></li><li><p><strong>offsetParent</strong>：距离元素最近的一个具有定位的祖宗元素（relative，absolute，fixed），若祖宗都不符合条件，offsetParent为body。</p></li><li><p><strong>offsetTop</strong>：元素到offsetParent顶部的距离。</p><p><img src="https://www.runoob.com/wp-content/uploads/2021/10/L0hUTUw15byA5Y-R5paH5qGjL2ltYWdlcy9Dc3NCb3hNb2RlbC5wbmc.png" alt="img"></p></li></ol><p><strong>滚动条的滚动高度</strong>：表示滚动条已经向下滚动的距离，即页面顶部到可视区域顶部的距离。</p><p><strong>可视区域的高度</strong>：表示当前浏览器窗口或容器中可见的部分的高度。</p><p><strong>当前图片的 offsetTop</strong>：表示图片顶部相对于文档顶部的距离。</p><p>根据上面的图解可知，当图片的滚动条滚动的高度加上可视区域的高度大于当前的图片的offsetTop，那么说明图片正在进入可视区域。这个时候便可以加载当前图片。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>模拟后台返回的图片url，遍历产生一个url集合，用于后面的懒加载使用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">imgUrls</span> = (<span class="params">num = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://robohash.org/<span class="subst">$&#123;i&#125;</span>.png`</span>;</span><br><span class="line">    urls.<span class="title function_">push</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> urls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>遍历图片url集合，渲染loading图片</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#123;styles[<span class="string">&#x27;box-one&#x27;</span>]&#125; ref=&#123;scrollRef&#125;&gt;</span><br><span class="line">      &#123;<span class="title function_">imgUrls</span>(<span class="number">100</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&#123;item&#125;</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> <span class="attr">src</span>=<span class="string">&#123;loadingUrl&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span>;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/2b9b931cc08a426cbd0a1788ed89dbddtplv-k3u1fbpfcp-jj-mark3024000q75.awebp#" alt="image.png"></p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p>监听容器的滚动事件，当容器滚动时计算容器的高度加上滚动条的高度大于当前图片的offsetTop时加载当前的图片。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> loadingUrl <span class="keyword">from</span> <span class="string">&#x27;@/assets/imgs/loading.jpg&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;../index.less&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片url</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">imgUrls</span> = (<span class="params">num = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://robohash.org/<span class="subst">$&#123;i&#125;</span>.png`</span>;</span><br><span class="line">    urls.<span class="title function_">push</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> urls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyLoading</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> scrollRef = <span class="title function_">useRef</span>(&#123;&#125; <span class="keyword">as</span> any);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 滚动事件</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeScroll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> clientHeight = scrollRef?.<span class="property">current</span>.<span class="property">clientHeight</span>; <span class="comment">//可视区域高度</span></span><br><span class="line">    <span class="keyword">const</span> scrollTop = scrollRef?.<span class="property">current</span>.<span class="property">scrollTop</span>; <span class="comment">//滚动条滚动高度</span></span><br><span class="line">    <span class="keyword">const</span> childNodes = scrollRef?.<span class="property">current</span>.<span class="property">childNodes</span>; <span class="comment">// 获取所有图片集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; childNodes.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = childNodes[j];</span><br><span class="line">      <span class="keyword">if</span> (scrollTop + clientHeight &gt; element.<span class="property">offsetTop</span>) &#123;</span><br><span class="line">        element.<span class="property">src</span> = element.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-src&#x27;</span>); <span class="comment">// 替换当前的src</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">changeScroll</span>(); <span class="comment">// 第一次渲染的时候替换loading图片</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">box-one</span>&#x27;]&#125; <span class="attr">ref</span>=<span class="string">&#123;scrollRef&#125;</span> <span class="attr">onScroll</span>=<span class="string">&#123;changeScroll&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;imgUrls(100).map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        return <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&#123;item&#125;</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> <span class="attr">src</span>=<span class="string">&#123;loadingUrl&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyLoading</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/59cabfcd5a6049bab860b480c72bd557tplv-k3u1fbpfcp-jj-mark3024000q75.awebp#" alt="image.png"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>方案二的实现思路利用浏览器提供的 <code>IntersectionObserver</code> API实现。<code>IntersectionObserver</code> API提供了一种方便的方式来监视目标元素和其祖先元素或视窗之间的交叉状态变化。当目标元素进入或离开视口时，可以触发回调函数，进行相应的操作。它的原理是通过注册一个回调函数来观察特定元素的交叉状态变化，并在满足条件时执行相应的操作。</p><p>使用 <code>IntersectionObserver</code> API非常简单，可以通过创建一个 <code>IntersectionObserver</code> 实例，并传入回调函数和选项对象来实现。回调函数会在目标元素的交叉状态发生变化时被调用，并接收一个参数，包含有关交叉状态的信息。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> loadingUrl <span class="keyword">from</span> <span class="string">&#x27;@/assets/imgs/loading.jpg&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;../index.less&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 图片url</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">imgUrls</span> = (<span class="params">num = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://robohash.org/<span class="subst">$&#123;i&#125;</span>.png`</span>;</span><br><span class="line">    urls.<span class="title function_">push</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> urls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyLoadImage</span> = (<span class="params">&#123; src, alt &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [imageSrc, setImageSrc] = <span class="title function_">useState</span>(loadingUrl);</span><br><span class="line">  <span class="keyword">const</span> imgRef = <span class="title function_">useRef</span>(<span class="literal">null</span> <span class="keyword">as</span> any);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">observer</span>: <span class="title class_">IntersectionObserver</span>;</span><br><span class="line">    <span class="keyword">if</span> (imgRef.<span class="property">current</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建IntersectionObserver实例</span></span><br><span class="line">      observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">        <span class="function">(<span class="params">[entry]</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 当图片进入可视区域时，设置图片地址进行加载</span></span><br><span class="line">          <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">            <span class="title function_">setImageSrc</span>(src);</span><br><span class="line">            observer.<span class="title function_">unobserve</span>(imgRef.<span class="property">current</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">rootMargin</span>: <span class="string">&#x27;0px 0px 200px 0px&#x27;</span>, <span class="comment">// 可视区域的上边距设置为200px</span></span><br><span class="line">       <span class="comment">//rootMargin 是 IntersectionObserver 的配置项之一，用于指定根元素边界框的外边距，以便扩大或缩小视口的大小</span></span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">      observer.<span class="title function_">observe</span>(imgRef.<span class="property">current</span>); <span class="comment">//开始观察目标元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (observer &amp;&amp; observer.<span class="property">unobserve</span>) &#123;</span><br><span class="line">        observer.<span class="title function_">unobserve</span>(imgRef.<span class="property">current</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [src]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">ref</span>=<span class="string">&#123;imgRef&#125;</span> <span class="attr">src</span>=<span class="string">&#123;imageSrc&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyLoading</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">box-two</span>&#x27;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;imgUrls(100).map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        return <span class="tag">&lt;<span class="name">LazyLoadImage</span> <span class="attr">src</span>=<span class="string">&#123;item&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;lazy load image&quot;</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyLoading</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/f5725e4841804cc0a4cf6d9938c2484btplv-k3u1fbpfcp-jj-mark3024000q75.awebp#" alt="2024-01-08 16.17.31.gif"></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>在初始化的时候，需要给imageSrc设置一个初始化的loading地址，如果没有的话，初始化的时候会加载多张图片。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>利用react的懒加载库<code>react-lazyload</code>，这里介绍几个它的常见属性：</p><ol><li>scrollContainer: 指定的滚动的区域，默认值是undefined，如果没有指定默认是窗口的视图作为滚动区域。</li><li>offset: 元素距离视口顶部的距离，当达到这个距离时，元素将被加载。</li><li>scroll: 是否监听滚动</li><li>height: 渲染元素的占位符的高度。</li><li>overflow : 如果溢出容器，延迟加载组件</li></ol><p>因为这里实现的图片懒加载是局部懒加载，所以需要指定 <code>scrollContainer</code>，<code>scrollContainer</code> 的值DOM对象。在实现的过程中，同时需要设置overflow为true，以及height的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> react, &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">LazyLoad</span> <span class="keyword">from</span> <span class="string">&#x27;react-lazyload&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;../index.less&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片url</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">imgUrls</span> = (<span class="params">num = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://robohash.org/<span class="subst">$&#123;i&#125;</span>.png`</span>;</span><br><span class="line">    urls.<span class="title function_">push</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> urls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyLoading</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> scrollRef = <span class="title function_">useRef</span>(&#123;&#125; <span class="keyword">as</span> any);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">box-three</span>&#x27;]&#125; <span class="attr">ref</span>=<span class="string">&#123;scrollRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;imgUrls(100).map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        return (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">LazyLoad</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">height</span>=<span class="string">&#123;200&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">overflow</span>=<span class="string">&#123;true&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">offset</span>=<span class="string">&#123;0&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">key</span>=<span class="string">&#123;item&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scroll</span>=<span class="string">&#123;true&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scrollContainer</span>=<span class="string">&#123;scrollRef.current&#125;</span> // <span class="attr">DOM</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;item&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">LazyLoad</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        );</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyLoading</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2023/12/04/%E9%97%AD%E5%8C%85/"/>
      <url>/2023/12/04/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>避免变量全局污染</li><li>使数据私有化，外部无法修改内部数据</li><li>可以让外部可以使用内部的私有数据</li></ol><p>以上三点其实都是函数的作用，而不是闭包的独特作用</p><p>！闭包的核心作用是：使变量可以驻留在内存，不被回收</p><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>结果输出为11，12，13</p><p>但是此时a为全局变量，如果别人不小心对a又重复赋值了，那么结果就不是我们预期的结果</p><p>那此时我们就不让a成为全局变量，把a的定义放在函数内部，让a成为函数的私有变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>此时就可以满足上面提到的函数的作用（第三条只要加个return就可以实现）</p><p>但是问题出现了：这次的结果三次都为11，这是因为函数在执行完一次后里面的变量就会被释放掉，下一次执行时又会重新对a进行赋值，所以结果一直为11</p><h4 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><p>条件：</p><ol><li>必须有个子函数 </li><li>子函数必须要调用父函数里面的变量</li></ol><p>实现自增的原因：</p><ol><li>执行的是f(),所以实际上执行的是子函数b，fn只在给f定义的时候执行了一次，所以后面let a &#x3D; 10也没有被执行</li><li>闭包函数内的变量可以保存下来</li></ol><p>我的疑惑：</p><ol><li>为什么要在下面重新定义一个f函数</li><li>为什么要加return       A ：1.因为要返回b函数？  2.最后f调用的是a变量，（如果外部想要使用闭包里面的变量，就要用return？）</li></ol><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>变量长时间驻留在内存，如果处理不当可能造成内存泄漏，所以用完可以手动清除</p><p>在最后加上下面的代码即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this（普通函数）————初版</title>
      <link href="/2023/12/03/this%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2023/12/03/this%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="this（普通函数"><a href="#this（普通函数" class="headerlink" title="this（普通函数)"></a>this（普通函数)</h2><h4 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h4><p>this———用于访问当前方法所属的对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">12</span>,</span><br><span class="line">    fn：<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>===obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>当前这个方法fn是属于obj，所以this就是obj，所以结果为true</p><p>这时用另一种写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">fn</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>===obj)</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>这种后添的写法结果也是完全一样</p><h4 id="this绑定方式"><a href="#this绑定方式" class="headerlink" title="this绑定方式"></a>this绑定方式</h4><p>this和函数的定义无关，和函数的调用有关，也可以说同一个函数的this可以有很多种值，这取决于怎么调用这个函数</p><p>1.直接调用——window || undefined  PS:在node环境里为global或者undefined</p><p>下面是直接调用函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>()</span><br></pre></td></tr></table></figure><p>结果为window，但这是个错误，因为show不属于任何对象，和this的定义有所冲突</p><p>在这里window相当于是一个兜底的角色，就是找不到this的时候，就用window来兜底</p><p>后面经过修改，如果加上了严格模式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br></pre></td></tr></table></figure><p>则结果为undefined</p><p>2.挂载在对象上，然后执行方法，那this就指向对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="property">fn</span>=show</span><br><span class="line">arr.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><p>此时输出的结果就是arr，因为此时show挂在了arr上面，属于对象arr，所以this输出的值就是arr</p><p>3.定时器——window</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(show,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在加了严格模式下输出结果仍为window</p><p>因为定时器本来就属于window，window来执行定时器，定时器来执行show，所以最终show是被window调用的</p><p>4.工具函数</p><p>使用call强制改变this的值   ps：apply </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">show.<span class="title function_">call</span>(<span class="number">12</span>)</span><br><span class="line">show.<span class="title function_">call</span>(<span class="string">&#x27;sdjlfhkajhf&#x27;</span>)<span class="comment">//这里要求变成个字符串</span></span><br><span class="line">show.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())<span class="comment">//这里要求变成个日期对象</span></span><br><span class="line">show.<span class="title function_">call</span>(&#123;<span class="attr">a</span>: <span class="number">12</span>&#125;)<span class="comment">//这里要求变成个json</span></span><br></pre></td></tr></table></figure><p>使用forEach</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的情况相当于第一种情况</p><p>函数并没有挂在arr上面，只是交给了forEach去调用</p><p>forEach实际上是</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="property">forEach</span>=<span class="keyword">function</span> (<span class="params">cb</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="variable language_">this</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="title function_">cb</span>(<span class="variable language_">this</span>[i])<span class="comment">//这里就是直接调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是forEach有第二个参数，这个参数就有绑定this的作用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,item)</span><br><span class="line">&#125;,<span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure><p>这里的用法就相当于是call的用法</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first</title>
      <link href="/2023/11/20/first/"/>
      <url>/2023/11/20/first/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/20/hello-world/"/>
      <url>/2023/11/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
