<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>canvas基础</title>
      <link href="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/04/06/canvas%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h5 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h5><p>Canvas的创建其实就是一个HTML标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>canvas - 创建<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;box-shadow: 0px 0px 5px #ccc; border-radius: 8px;&quot;</span>&gt;</span></span><br><span class="line">    当前浏览器不支持canvas元素，请升级或更换浏览器！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h5><p>id：画布的唯一标识，获取画布的时候可以用它</p><p>width：画布的宽度，这里需要说明在不设置画布宽度的时候，默认宽度为300像素</p><p>height：画布的高度，这里需要说明在不设置画布高度的时候，默认高度为150像素</p><p>style：画布的样式，例如正常情况下画布是没有边框或者阴影的，但上面示例中我们通过<code>style</code>属性给<code>&lt;canvas&gt;</code>标签设置了阴影和圆角样式。</p><h5 id="3-绘制上下文"><a href="#3-绘制上下文" class="headerlink" title="3.绘制上下文"></a>3.绘制上下文</h5><p>在Canvas的绘制中，Canvas本身是没有绘制能力的，它的所有绘制都是通过JavaScript来实现的</p><p>在Canvas没有绘制能力的情况下，JavaScript又如何在Canvas中实现元素的绘制呢？</p><p>这还得说到一个东西：<strong>绘制上下文</strong>。</p><p>获取Canvas 绘制上下文的方法为：<code>getContext()</code>，正是这个方法让Canvas具备绘制的能力。</p><h6 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.<span class="title function_">getContext</span>(contextType, contextAttributes)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li>contextType 为绘制上下文的类型，类型参数有：</li></ol><ul><li>2d：用于创建一个 CanvasRenderingContext2D 2D绘制上下文。</li><li>webgl：用于创建一个 WebGLRenderingContext 3D渲染上下文对象。且该类型只支持在实现WebGL版本1的浏览器上可用也就是 OpenGL ES 2.0。</li><li>webgl2：用于创建一个 WebGL2RenderingContext 3D渲染上下文对象。且该类型只支持在实现WebGL版本2的浏览器上可用也就是 OpenGL ES 3.0。</li><li>bitmaprenderer：用于创建一个只提供将 canvas 内容替换为指定ImageBitmap功能的ImageBitmapRenderingContext。</li></ul><ol start="2"><li>contextAttributes 为绘制上下文的属性，这些属性相对比较多，可以设置单个也可以同时设置多个，下面列一下，方便大家了解：</li></ol><ul><li>2D类型的参数有： (1)、<code>alpha</code> 它的值为Boolean类型，如果设置为false, 浏览器将认Canvas背景总是不透明的，这样可以做到一些性能提效。(2)、<code>willReadFrequently</code>，值也为Boolean类型，用于表明是否要重复操作，频繁调用<code>getImageData()</code>方法时能节省内存，但是仅Gecko内核浏览器支持。(3)、<code>storage</code>用于表明使用哪种方式存储，默认值 persisten，表示持久化存储。</li><li>3D类型的参数有： (1)、<code>alpha</code> 值为Boolean类型，指示画布是否包含alpha缓冲区。 (2)、<code>antialias</code> 值为Boolean类型，指示是否开启抗锯齿。 (3)、<code>depth</code> 值为Boolean类型，表示绘图缓冲区的深度缓冲区至少为16位。 (4)、<code>failIfMajorPerformanceCaveat</code>值为Boolean类型，指示如果系统性能较低，是否创建上下文。 (5)、<code>powerPreference</code>：对用户代理的提示，指示GPU的哪种配置适合WebGL上下文。可能的值是： <code>default</code>: 自动选择模式，自动决定哪种GPU配置最合适，为默认值。 <code>high-performance</code>: 高性能模式，优先考虑渲染性能而不是功耗。 <code>low-power</code>: 节能模式，优先考虑节能而不是渲染性能。 (6)、<code>premultipliedAlpha</code> 值为Boolean类型，表示页面合成器将假定绘图缓冲区包含具有预乘alpha的颜色。 (7)、<code>preserveDrawingBuffer</code> 值为Boolean类型，如果值为true，则不会清除缓冲区并保留其值，直到被清除或被使用者覆盖。 (8)、<code>stencil</code> 值为Boolean类型，表示绘图缓冲区具有至少8位的模板缓冲区。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);<span class="comment">//获取绘制上下文</span></span><br></pre></td></tr></table></figure><h5 id="4-绘制方式"><a href="#4-绘制方式" class="headerlink" title="4.绘制方式"></a>4.绘制方式</h5><p>stroke()  描边</p><p>fill() 填充</p><p>strokeStyle  描边的样式</p><p>fillStyle  填充的样式</p><p>值得注意的是，<code>strokeStyle</code> 和 <code>fillStyle</code> 属性的设置是一次设置永久有效的，想要改变必须重新设置其他值来覆盖原有的值。</p><h5 id="5-基本绘制形状"><a href="#5-基本绘制形状" class="headerlink" title="5.基本绘制形状"></a>5.基本绘制形状</h5><h6 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h6><p>直线的绘制就是设置两个点，然后连接这两个点形成一条直线，那么这两个点如何设置呢？</p><h3 id="moveTo-x-y"><a href="#moveTo-x-y" class="headerlink" title="moveTo(x, y)"></a>moveTo(x, y)</h3><p>设置初始位置，参数为初始位置x和y的坐标点</p><h3 id="lineTo-x-y"><a href="#lineTo-x-y" class="headerlink" title="lineTo(x, y)"></a>lineTo(x, y)</h3><p>设置指定位置，参数为指定位置x和y的坐标点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>); <span class="comment">// 获取Canvas</span></span><br><span class="line">    <span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>); <span class="comment">// 获取绘制上下文</span></span><br><span class="line">    ctx.<span class="property">strokeStyle</span> = <span class="string">&quot;#f00&quot;</span> <span class="comment">// 描边样式设置为红色</span></span><br><span class="line">    <span class="comment">// 画一条（50， 50） 到 （400， 50）的直线</span></span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">50</span>, <span class="number">50</span>) </span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">400</span>, <span class="number">50</span>)</span><br><span class="line">    ctx.<span class="title function_">stroke</span>() </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连续的直线只需要设置一个起始点</span></span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">50</span>, <span class="number">100</span>) </span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">50</span>, <span class="number">400</span>)</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">    ctx.<span class="title function_">stroke</span>() </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直线样式</p><h4 id="lineWidth"><a href="#lineWidth" class="headerlink" title="lineWidth"></a>lineWidth</h4><p>设置直线的粗细，默认值为1，且属性值必须为正数。</p><h4 id="lineCap"><a href="#lineCap" class="headerlink" title="lineCap"></a>lineCap</h4><p>设置直线端点显示的样式。可选值为：butt，round 和 square（通过添加一个宽度相等且高度为线条粗细一半的框，使线条末端呈方形）。默认是 butt。</p><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/e9ef1310875a4b5a8b8f12e07aaca8e7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-17124660987172-17124661132204.awebp" alt="image.png"></p><h4 id="lineJoin"><a href="#lineJoin" class="headerlink" title="lineJoin"></a>lineJoin</h4><p>设置两线段连接处所显示的样子。可选值为：round, bevel 和 miter。默认是 miter。</p><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/4521845c798e4631b6ea17f3017ee0a2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image.png"></p><h6 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制一个三角形</span></span><br><span class="line">   ctx.<span class="title function_">moveTo</span>(<span class="number">50</span>, <span class="number">100</span>) </span><br><span class="line">   ctx.<span class="title function_">lineTo</span>(<span class="number">50</span>, <span class="number">400</span>)</span><br><span class="line">   ctx.<span class="title function_">lineTo</span>(<span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">   ctx.<span class="title function_">lineTo</span>(<span class="number">50</span>, <span class="number">100</span>) </span><br><span class="line">   ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果是填充一个三角形，则只需两条直线就行，它会默认闭合。</span></span><br><span class="line">   ctx.<span class="title function_">beginPath</span>()</span><br><span class="line">   ctx.<span class="title function_">moveTo</span>(<span class="number">200</span>, <span class="number">200</span>) </span><br><span class="line">   ctx.<span class="title function_">lineTo</span>(<span class="number">400</span>, <span class="number">200</span>)</span><br><span class="line">   ctx.<span class="title function_">lineTo</span>(<span class="number">400</span>, <span class="number">370</span>)</span><br><span class="line">   ctx.<span class="title function_">fill</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩形描边</span></span><br><span class="line"><span class="title function_">rect</span>(x, y, width, height)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制矩形</span></span><br><span class="line"><span class="title function_">strokeRect</span>(x, y, width, height)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充矩形</span></span><br><span class="line"><span class="title function_">fillRect</span>(x, y, width, height)</span><br></pre></td></tr></table></figure><p>上述的三个方法都可以用来绘制矩形，他们的传参都是一样的，其中x和y是起始点的x坐标和y坐标，width为矩形的宽，height为矩形的高。</p><p>合成版 strokeRect() fillRect(）</p><h6 id="圆弧和圆"><a href="#圆弧和圆" class="headerlink" title="圆弧和圆"></a>圆弧和圆</h6><p>Canvas提供了绘制圆弧或圆的方法：<code>arc()</code>，该方法提供了给定坐标值（x,y）以后，按给定的半径（r）大小，从给定的起始点（startAngle）位置，默认顺时针方向绘制圆弧或圆到给定的终点（endAngle）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">arc</span>(x, y, radius, startAngle, endAngle, anticlockwise);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>x，y 为圆弧中心或圆的圆心坐标、</li><li>radius 为圆弧的半径或圆的半径、</li><li>startAngle 为圆弧或圆的起始点，从x轴方向开始计算，且单位为弧度、</li><li>endAngle 为圆弧或圆的终点，单位也是为弧度</li><li>anticlockwise 是一个可选参数，可选值为Boolean类型，用它来表示圆弧或圆的绘制方向，默认为false，顺时针绘制圆弧或圆，true是逆时针</li></ul><p>角度转弧度的公式为：<code>弧度 = 角度 * Math.PI / 180</code></p><h6 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h6><p>二次贝塞尔曲线<img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/167c7a62849d43d0948f2707c020048ctplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image.png"></p><p>如图就是一个二次贝塞尔曲线，他的绘制需要一个控制点来控制曲线，具体的语法为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quadraticCurveTo(cp1x, cp1y, x, y)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cp1x和cp1y为控制点坐标</li><li>x和y为结束点坐标</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">250</span>);</span><br><span class="line">ctx.<span class="title function_">quadraticCurveTo</span>(<span class="number">250</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">250</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/9a18a871e84c42468595aa09989497d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-17124668552188.awebp" alt="image.png"></p><p>三次贝塞尔曲线</p><p>三次贝塞尔曲线和二次贝塞尔曲线不同的是三次贝塞尔曲线有两个控制点。具体的语法为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x, y)</span><br></pre></td></tr></table></figure><p>参数为：</p><ul><li>cp1x和cp1y为第一个控制点坐标</li><li>cp2x和cp2y为第二个控制点坐标</li><li>x和y为结束点坐标</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">250</span>);</span><br><span class="line">ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">150</span>, <span class="number">100</span>, <span class="number">350</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">250</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/f581609289004cf187857eba31a87dbftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-171246692279710.awebp" alt="image.png"><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/9b6508146ea944a398a2c497c34b51f5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-171246693675912.awebp" alt="20190809163503842.gif"></p><p>一次贝塞尔曲线：</p><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/b93f24fcb7e04ebc89959f9dfd9b6708tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-171246696719314.awebp" alt="20190809163745169.gif"></p><p>二次贝塞尔曲线：</p><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/eb035911f33541ef962436c1afaf6773tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-171246698547116.awebp" alt="20190809163835500.gif"></p><p>三次贝塞尔曲线：</p><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/95800539044e48eabd40f243f59aee35tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-171246700459218.awebp" alt="20190809163955483.gif"></p><p>四次贝塞尔曲线：</p><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/2326b343bc2143548e424e0235785233tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-171246701805020.awebp" alt="20190809164018347.gif"></p><p>五次贝塞尔曲线：</p><h5 id="6-路径的开启和闭合"><a href="#6-路径的开启和闭合" class="headerlink" title="6.路径的开启和闭合"></a>6.路径的开启和闭合</h5><p>beginPath()</p><p><code>beginPath()</code>方法用于开始一条路径或重置当前的路径</p><p>当我们不重新开启一条新路径，两条路径就会默认为是一条路径来绘制，因此就得不到我们想要的效果。想分开绘制我们就需要重新开启新的路径。</p><p>closePath()</p><p><code>closePath()</code>方法和<code>beginPath()</code>方法正好相反，用来关闭一条路径，规范的用法其实是他们两个搭配使用，每次绘制都先开启一条新路径，完事关闭该路径</p><p>因此每次我们连续绘制时，若需要分开绘制，那么一定要在每次绘制前重新开启新的路径。</p><h5 id="7-绘制文本"><a href="#7-绘制文本" class="headerlink" title="7.绘制文本"></a>7.绘制文本</h5><p>strokeText()方法是以描边的方式绘制文字的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">strokeText</span>(txt, x, y, maxWidth)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>txt：是绘制的文本内容</li><li>x、y：为绘制文本的起始位置坐标</li><li>maxWidth：可选参数，为文本绘制的最大宽度。</li></ul><p>当文案大于最大宽度时不是裁剪或者换行，而是缩小。</p><p>fillText()方法是以填充的方式绘制文字的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="title function_">fillText</span>(txt, x, y, maxWidth)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>txt：是绘制的文本内容</li><li>x、y：为绘制文本的起始位置坐标</li><li>maxWidth：可选参数，为文本绘制的最大宽度。</li></ul><h6 id="font"><a href="#font" class="headerlink" title="font"></a>font</h6><p><code>font</code>属性的设置可以改变字号和字体，不设置的情况下默认是：<code>10px sans-serif</code>。</p><h6 id="textAlign"><a href="#textAlign" class="headerlink" title="textAlign"></a>textAlign</h6><p><code>textAlign</code>属性的设置可以改变文本对齐的方式。默认值是 <code>start</code>，可选值有：<code>left</code>、<code>right</code>、<code>center</code>、<code>start</code>和<code>end</code>。</p><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/40b13ba4e7a04a7ba6b541881923bad6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-171246747696522.awebp" alt="image.png"></p><p>如图我们可以看到各个参数对应的效果，我们会发现<code>start</code>和<code>left</code>的效果基本一样，还有<code>end</code>和<code>right</code>的效果也基本一样，那么<code>start</code>和<code>left</code>，<code>end</code>和<code>right</code>是不是等价的呢？答案肯定是否定的。因为如果是等价的那就没必要设置两个属性了。</p><p>那他们既然不一样，那他们有什么区别呢？这我们需要结合另一个属性：<code>direction</code> 来看。</p><h6 id="direction"><a href="#direction" class="headerlink" title="direction"></a>direction</h6><p><code>direction</code>属性可以设置文本的方向。默认值是 <code>inherit</code>， 可选值为：<code>ltr</code>（文本方向从左向右）、<code>rtl</code>（文本方向从右向左）、<code>inherit</code>（根据情况继承 Canvas元素或者 Document 。）。</p><p> <code>direction</code> 属性会对 <code>textAlign</code> 属性产生影响。</p><p>如果 <code>direction</code> 属性设置为 <code>ltr</code>，则<code>textAlign</code>属性的 <code>left</code> 和 <code>start</code> 的效果相同，<code>right</code> 和 <code>end</code> 的效果相同，</p><p>如果 <code>direction</code> 属性设置为 <code>rtl</code>，则 <code>textAlign</code>属性的 <code>left</code> 和 <code>end</code> 的效果相同，<code>right</code> 和 <code>start</code> 的效果相同。</p><h6 id="textBaseline"><a href="#textBaseline" class="headerlink" title="textBaseline"></a>textBaseline</h6><p><code>textBaseline</code>属性设置基于基线对齐的文字垂直方向的对齐方式。默认值是<code>alphabetic</code>，可选值为：<code>top</code>、<code>hanging</code>、<code>middle</code>、<code>alphabetic</code>、<code>ideographic</code>和<code>bottom</code>。</p><p><img src="/2024/04/06/canvas%E5%9F%BA%E7%A1%80/8ceff6bea0e142aba3853e8362176284tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-171246772220024.awebp" alt="image.png"></p><h5 id="8-绘制图像"><a href="#8-绘制图像" class="headerlink" title="8.绘制图像"></a>8.绘制图像</h5><h6 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</span><br></pre></td></tr></table></figure><h6 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h6><ul><li>image：绘制的元素（图像）。</li><li>sx、sy：裁剪框左上角的坐标。</li><li>sWidth、sHeight：裁剪框的宽度和高度。</li><li>dx、dy：绘制元素（图像）时左上角的坐标。</li><li>dWidth、dHeight：绘制元素（图像）的宽度和高度。如果不设置，则在绘制时image宽度和高度不会缩放，超出画布则图片不完整</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;//图片url&#x27;</span>;</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">150</span>, <span class="number">1650</span>, <span class="number">700</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">550</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js继承</title>
      <link href="/2024/03/31/js%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/03/31/js%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h4 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h4><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p><p>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/31/js%E7%BB%A7%E6%89%BF/166c2c0107fd80c7tplv-t2oaga2asx-zoom-in-crop-mark1512000.awebp" alt="img"></p><p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(instance1.<span class="property">colors</span>); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="title function_">alert</span>(instance2.<span class="property">colors</span>); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2、借用构造函数继承"><a href="#2、借用构造函数继承" class="headerlink" title="2、借用构造函数继承"></a>2、借用构造函数继承</h4><p>使用父类的构造函数来增强子类<strong>实例</strong>，等同于复制父类的实例给子类（不使用原型）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="title function_">SuperType</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span>=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">SubType</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">instance1.<span class="property">color</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(instance1.<span class="property">color</span>);<span class="comment">//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="title function_">alert</span>(instance2.<span class="property">color</span>);<span class="comment">//&quot;red,green,blue&quot;</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将SuperType中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承原型属性&#x2F;方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h4 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h4><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>; </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(instance1.<span class="property">colors</span>); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Nicholas&quot;;</span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="title function_">alert</span>(instance2.<span class="property">colors</span>); <span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance2.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Greg&quot;;</span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/31/js%E7%BB%A7%E6%89%BF/166c2c010c537ff8tplv-t2oaga2asx-zoom-in-crop-mark1512000.awebp" alt="img"></p><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性name，color。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性name，color。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性&#x2F;方法。</p><h4 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h4><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<code>浅复制</code>，将构造函数F的原型直接指向传入的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">object</span>(person);</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="title function_">object</span>(person);</span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">friends</span>);   <span class="comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><p>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的object方法。</p><h4 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h4><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="title function_">object</span>(original); <span class="comment">// 通过调用 object() 函数创建一个新对象</span></span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="comment">// 以某种方式来增强对象</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">createAnother</span>(person);</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">//&quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h4 id="6、寄生组合式继承"><a href="#6、寄生组合式继承" class="headerlink" title="6、寄生组合式继承"></a>6、寄生组合式继承</h4><p>结合借用构造函数传递参数和寄生模式实现继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(superType.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = subType;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类原型指向子类</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;xyc&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;2&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span></span><br><span class="line">instance2.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;3&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/31/js%E7%BB%A7%E6%89%BF/166c2c0109df5438tplv-t2oaga2asx-zoom-in-crop-mark1512000.awebp" alt="img"></p><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p><h4 id="7、混入方式继承多个对象"><a href="#7、混入方式继承多个对象" class="headerlink" title="7、混入方式继承多个对象"></a>7、混入方式继承多个对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="title class_">SuperClass</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">     <span class="title class_">OtherSuperClass</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">SuperClass</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="title class_">OtherSuperClass</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Object.assign</code>会把  <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p><h4 id="8、ES6类继承extends"><a href="#8、ES6类继承extends" class="headerlink" title="8、ES6类继承extends"></a>8、ES6类继承extends</h4><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">height, width</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">calcArea</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="title function_">calcArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">height</span> * <span class="variable language_">this</span>.<span class="property">width</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rectangle.<span class="property">area</span>);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(length, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">height</span> * <span class="variable language_">this</span>.<span class="property">width</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square.<span class="property">area</span>);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_inherits</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(superType &amp;&amp; superType.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">        <span class="attr">constructor</span>: &#123;</span><br><span class="line">            <span class="attr">value</span>: subType,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (superType) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="property">setPrototypeOf</span> </span><br><span class="line">            ? <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(subType, superType) </span><br><span class="line">            : subType.<span class="property">__proto__</span> = superType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、函数声明和类声明的区别</p><p>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(); </span><br><span class="line"><span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>2、ES5继承和ES6继承的区别</p><ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li><li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>节流与防抖</title>
      <link href="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
      <url>/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<p>因为要做一个记忆翻牌配对小游戏，然后在学习时偶然看到“节流”二字，然后就顺便去看了看所谓的“节流”</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><h5 id="1-啥是节流"><a href="#1-啥是节流" class="headerlink" title="1.啥是节流"></a>1.啥是节流</h5><p> n 秒内只执行一次事件，即使n 秒内事件重复触发，也只有一次生效。</p><p>如果这不好理解，那就假设一个场景：</p><p>1.你设计了一个表单，这个表单提交的数据内容很多。</p><p>2.你的有些用户闲得很无聊，写完表单以后疯狂点击提交按钮。</p><p>3.你的后端同事走到你面前指着崩溃的服务器来向你抱怨。</p><p>这就像打游戏放技能一样，放完一次技能后就有一段的冷却时间</p><p><strong>所以我的第一想法肯定是给这个button一个冷却时间</strong></p><p>现在在我面前的有两个东西：一个按钮提交的功能，一个冷却时间，假设为5秒</p><p>牵扯到时间会让我第一时间想到 setTimeout和setInterval，首先排除setInterval，因为提交表单这个功能我不希望它循环执行，所以我选择setTimeout。</p><p>假设你现在正在玩游戏，游戏有一个技能，它的技能CD是两秒，那么我们就需要判断用户是否在两秒内多处点击了这个技能，如果多次点击，那么无事发生(返回一个空函数)，如果不在CD，那么返回这个技能的特效(技能执行的函数)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fnOnclick</span> = (<span class="params"></span>)=&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;技能已经开启！&quot;</span>)</span><br><span class="line">&lt;button onClick =&#123;<span class="title function_">cdTime</span>(fnOnclick,<span class="number">2000</span>)&#125;&gt;技能&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>在这里我们需要知道cdTime这个函数只是一个外壳函数，它真正的意义在于传递我们需要的参数，它并不是我们希望onclick真正要执行的函数！cdTime返回的那个函数才是我们真正想执行的函数</p><p>现在我们设计cdTime，也就是我们限制 技能 只能在两秒之内释放。</p><h5 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn0nClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>. <span class="title function_">log</span>(<span class="string">&quot;技能已经开启!!&quot;</span>) </span><br><span class="line"><span class="comment">//这就是你按钮提交的onclick事件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cdTime</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">CD</span> =<span class="literal">false</span>; <span class="comment">//首先你的技能刚开始是没有冷却时间的</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">CD</span>) &#123;  <span class="comment">//ok, 当你想放技能的时候，你需要判断是否在冷却时间内，如果在，对不起不能放!</span></span><br><span class="line">   <span class="variable language_">console</span>. log (<span class="string">&quot;不行，cd中&quot;</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//这里写null, 空值都可以</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="variable constant_">CD</span> = <span class="literal">true</span>; <span class="comment">//这步我的技能还没放，即将要释放。因为setTimout是异步执行， 所以cd在两秒以后才会被修改，这一步是限制用户频繁点击技能键时，让函数返回一个空值。</span></span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">       <span class="comment">//现在没有进入cd,当你放技能的时候然后开始启用</span></span><br><span class="line">    <span class="variable language_">console</span>. <span class="title function_">log</span>(<span class="string">&quot;技能成功释放&quot;</span>);</span><br><span class="line">    <span class="variable constant_">CD</span> = <span class="literal">false</span>; <span class="comment">//ok, 现在我技能释放完毕，把cd的属性清空。</span></span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">   &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我在看完节流后又摸过去看了看防抖</p><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><h5 id="1-啥是防抖"><a href="#1-啥是防抖" class="headerlink" title="1.啥是防抖"></a>1.啥是防抖</h5><p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p><p>我们拿一个点击按钮来举例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSearch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发请求&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick =<span class="function">()=&gt;</span>&#123;getSearch&#125;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>现在我们尝试疯狂点击按钮就会疯狂发送请求。</p><p><img src="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/1.gif" alt="img"></p><p>我们现在来修改一下这个函数，我们思考一下🤔，假设我们不借助 debounce 可以实现一个伪防抖的功能吗？答案是百分百可以的。我们先在这个文件下设定一个变量叫做 timerID</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后我们设定一个定时器，来使这个 console.log(“发请求”) 在 1.5s 后执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSearch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发请求&quot;</span>)</span><br><span class="line">    &#125;，<span class="number">1500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里要补充讲一下：setTimeout的返回值</p><p><img src="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/2.png" alt="img"><img src="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/3.png" alt="img"></p><p>其实 setTimeout 会在 setTimeout 执行的时候返回一个大于 0 的正整数。 所以我们这句话其实是在给 timerID 赋值！ 并不是将 setTimeout 函数本身赋值给 timerID 这个变量。</p><p><img src="/2024/03/16/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/4.png" alt="img"></p><p>这里我们需要特别搞清楚 setTimout函数本身执行的时候，是马上赋值的，并不是等到 1.5s 后再赋值的。什么意思呢？ 我设置了大约在10几年后再执行的一个函数，千万不要觉得 timerID 是会在10年以后才会被赋值。</p><p>为什么要这样设计呢？因为如果这样执行的话，就会给我们一个反悔的机会。还说上面的例子。假设我在 5 年后突然反悔不想执行了。我只需要取消这个 timerID 就可以中途放弃执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cancelSearch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我取消的ID是&quot;</span>，timerId)</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 timerID 就是每一个 setTimeout 的身份证。每当你执行一次 setTimout 后，setTimout 所接收的回调函数就会被分配一个唯一 ID，来被放进任务队列。 而 clearTimeout 的功能恰好就是清除位于任务队列里指定的 id 所绑定的那个回调函数。</p><h5 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSearch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timerId)&#123;</span><br><span class="line">        <span class="title function_">clreaTimeout</span>(timerId)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当我们每次执行 getSearch 之前，如果当前任务队列里有上一次同样的任务，我们就先清除掉</span></span><br><span class="line">    </span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发请求&quot;</span>)</span><br><span class="line">    &#125;，<span class="number">1200</span>)</span><br><span class="line">    <span class="comment">//然后再去开启一个定时器任务推进任务队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React实现图片懒加载</title>
      <link href="/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>图片懒加载是一种优化网页性能的技术，它允许在用户滚动到图片位置之前延迟加载图片。通过懒加载，可以在用户需要查看图片时才加载图片，避免了不必要的图片加载，从而提高了网页的加载速度和用户体验。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>在说明思路之前，先了解几个常见的视图属性。</p><ol><li><p><strong>clientHeight</strong>：元素的像素高度,包含元素的高度+内边距,不包含水平滚动条,边框和外边距。</p></li><li><p><strong>scrollTop</strong>：滚动条滚动的高度，它指的是内容区的顶部到可视区域顶部的距离。</p></li><li><p><strong>offsetParent</strong>：距离元素最近的一个具有定位的祖宗元素（relative，absolute，fixed），若祖宗都不符合条件，offsetParent为body。</p></li><li><p><strong>offsetTop</strong>：元素到offsetParent顶部的距离。</p><p><img src="https://www.runoob.com/wp-content/uploads/2021/10/L0hUTUw15byA5Y-R5paH5qGjL2ltYWdlcy9Dc3NCb3hNb2RlbC5wbmc.png" alt="img"></p></li></ol><p><strong>滚动条的滚动高度</strong>：表示滚动条已经向下滚动的距离，即页面顶部到可视区域顶部的距离。</p><p><strong>可视区域的高度</strong>：表示当前浏览器窗口或容器中可见的部分的高度。</p><p><strong>当前图片的 offsetTop</strong>：表示图片顶部相对于文档顶部的距离。</p><p>根据上面的图解可知，当图片的滚动条滚动的高度加上可视区域的高度大于当前的图片的offsetTop，那么说明图片正在进入可视区域。这个时候便可以加载当前图片。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>模拟后台返回的图片url，遍历产生一个url集合，用于后面的懒加载使用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">imgUrls</span> = (<span class="params">num = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://robohash.org/<span class="subst">$&#123;i&#125;</span>.png`</span>;</span><br><span class="line">    urls.<span class="title function_">push</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> urls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>遍历图片url集合，渲染loading图片</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#123;styles[<span class="string">&#x27;box-one&#x27;</span>]&#125; ref=&#123;scrollRef&#125;&gt;</span><br><span class="line">      &#123;<span class="title function_">imgUrls</span>(<span class="number">100</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&#123;item&#125;</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> <span class="attr">src</span>=<span class="string">&#123;loadingUrl&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span>;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/2b9b931cc08a426cbd0a1788ed89dbddtplv-k3u1fbpfcp-jj-mark3024000q75.awebp#" alt="image.png"></p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p>监听容器的滚动事件，当容器滚动时计算容器的高度加上滚动条的高度大于当前图片的offsetTop时加载当前的图片。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> loadingUrl <span class="keyword">from</span> <span class="string">&#x27;@/assets/imgs/loading.jpg&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;../index.less&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片url</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">imgUrls</span> = (<span class="params">num = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://robohash.org/<span class="subst">$&#123;i&#125;</span>.png`</span>;</span><br><span class="line">    urls.<span class="title function_">push</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> urls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyLoading</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> scrollRef = <span class="title function_">useRef</span>(&#123;&#125; <span class="keyword">as</span> any);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 滚动事件</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeScroll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> clientHeight = scrollRef?.<span class="property">current</span>.<span class="property">clientHeight</span>; <span class="comment">//可视区域高度</span></span><br><span class="line">    <span class="keyword">const</span> scrollTop = scrollRef?.<span class="property">current</span>.<span class="property">scrollTop</span>; <span class="comment">//滚动条滚动高度</span></span><br><span class="line">    <span class="keyword">const</span> childNodes = scrollRef?.<span class="property">current</span>.<span class="property">childNodes</span>; <span class="comment">// 获取所有图片集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; childNodes.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = childNodes[j];</span><br><span class="line">      <span class="keyword">if</span> (scrollTop + clientHeight &gt; element.<span class="property">offsetTop</span>) &#123;</span><br><span class="line">        element.<span class="property">src</span> = element.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-src&#x27;</span>); <span class="comment">// 替换当前的src</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">changeScroll</span>(); <span class="comment">// 第一次渲染的时候替换loading图片</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">box-one</span>&#x27;]&#125; <span class="attr">ref</span>=<span class="string">&#123;scrollRef&#125;</span> <span class="attr">onScroll</span>=<span class="string">&#123;changeScroll&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;imgUrls(100).map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        return <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&#123;item&#125;</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> <span class="attr">src</span>=<span class="string">&#123;loadingUrl&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyLoading</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/59cabfcd5a6049bab860b480c72bd557tplv-k3u1fbpfcp-jj-mark3024000q75.awebp#" alt="image.png"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>方案二的实现思路利用浏览器提供的 <code>IntersectionObserver</code> API实现。<code>IntersectionObserver</code> API提供了一种方便的方式来监视目标元素和其祖先元素或视窗之间的交叉状态变化。当目标元素进入或离开视口时，可以触发回调函数，进行相应的操作。它的原理是通过注册一个回调函数来观察特定元素的交叉状态变化，并在满足条件时执行相应的操作。</p><p>使用 <code>IntersectionObserver</code> API非常简单，可以通过创建一个 <code>IntersectionObserver</code> 实例，并传入回调函数和选项对象来实现。回调函数会在目标元素的交叉状态发生变化时被调用，并接收一个参数，包含有关交叉状态的信息。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> loadingUrl <span class="keyword">from</span> <span class="string">&#x27;@/assets/imgs/loading.jpg&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;../index.less&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 图片url</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">imgUrls</span> = (<span class="params">num = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://robohash.org/<span class="subst">$&#123;i&#125;</span>.png`</span>;</span><br><span class="line">    urls.<span class="title function_">push</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> urls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyLoadImage</span> = (<span class="params">&#123; src, alt &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [imageSrc, setImageSrc] = <span class="title function_">useState</span>(loadingUrl);</span><br><span class="line">  <span class="keyword">const</span> imgRef = <span class="title function_">useRef</span>(<span class="literal">null</span> <span class="keyword">as</span> any);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">observer</span>: <span class="title class_">IntersectionObserver</span>;</span><br><span class="line">    <span class="keyword">if</span> (imgRef.<span class="property">current</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建IntersectionObserver实例</span></span><br><span class="line">      observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">        <span class="function">(<span class="params">[entry]</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 当图片进入可视区域时，设置图片地址进行加载</span></span><br><span class="line">          <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">            <span class="title function_">setImageSrc</span>(src);</span><br><span class="line">            observer.<span class="title function_">unobserve</span>(imgRef.<span class="property">current</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">rootMargin</span>: <span class="string">&#x27;0px 0px 200px 0px&#x27;</span>, <span class="comment">// 可视区域的上边距设置为200px</span></span><br><span class="line">       <span class="comment">//rootMargin 是 IntersectionObserver 的配置项之一，用于指定根元素边界框的外边距，以便扩大或缩小视口的大小</span></span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">      observer.<span class="title function_">observe</span>(imgRef.<span class="property">current</span>); <span class="comment">//开始观察目标元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (observer &amp;&amp; observer.<span class="property">unobserve</span>) &#123;</span><br><span class="line">        observer.<span class="title function_">unobserve</span>(imgRef.<span class="property">current</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [src]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">ref</span>=<span class="string">&#123;imgRef&#125;</span> <span class="attr">src</span>=<span class="string">&#123;imageSrc&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyLoading</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">box-two</span>&#x27;]&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;imgUrls(100).map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        return <span class="tag">&lt;<span class="name">LazyLoadImage</span> <span class="attr">src</span>=<span class="string">&#123;item&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;lazy load image&quot;</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyLoading</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/02/React%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/f5725e4841804cc0a4cf6d9938c2484btplv-k3u1fbpfcp-jj-mark3024000q75.awebp#" alt="2024-01-08 16.17.31.gif"></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>在初始化的时候，需要给imageSrc设置一个初始化的loading地址，如果没有的话，初始化的时候会加载多张图片。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>利用react的懒加载库<code>react-lazyload</code>，这里介绍几个它的常见属性：</p><ol><li>scrollContainer: 指定的滚动的区域，默认值是undefined，如果没有指定默认是窗口的视图作为滚动区域。</li><li>offset: 元素距离视口顶部的距离，当达到这个距离时，元素将被加载。</li><li>scroll: 是否监听滚动</li><li>height: 渲染元素的占位符的高度。</li><li>overflow : 如果溢出容器，延迟加载组件</li></ol><p>因为这里实现的图片懒加载是局部懒加载，所以需要指定 <code>scrollContainer</code>，<code>scrollContainer</code> 的值DOM对象。在实现的过程中，同时需要设置overflow为true，以及height的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> react, &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">LazyLoad</span> <span class="keyword">from</span> <span class="string">&#x27;react-lazyload&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;../index.less&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片url</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">imgUrls</span> = (<span class="params">num = <span class="number">10</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://robohash.org/<span class="subst">$&#123;i&#125;</span>.png`</span>;</span><br><span class="line">    urls.<span class="title function_">push</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> urls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyLoading</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> scrollRef = <span class="title function_">useRef</span>(&#123;&#125; <span class="keyword">as</span> any);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles[</span>&#x27;<span class="attr">box-three</span>&#x27;]&#125; <span class="attr">ref</span>=<span class="string">&#123;scrollRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;imgUrls(100).map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        return (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">LazyLoad</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">height</span>=<span class="string">&#123;200&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">overflow</span>=<span class="string">&#123;true&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">offset</span>=<span class="string">&#123;0&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">key</span>=<span class="string">&#123;item&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scroll</span>=<span class="string">&#123;true&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scrollContainer</span>=<span class="string">&#123;scrollRef.current&#125;</span> // <span class="attr">DOM</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;item&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">LazyLoad</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        );</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyLoading</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2023/12/04/%E9%97%AD%E5%8C%85/"/>
      <url>/2023/12/04/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>避免变量全局污染</li><li>使数据私有化，外部无法修改内部数据</li><li>可以让外部可以使用内部的私有数据</li></ol><p>以上三点其实都是函数的作用，而不是闭包的独特作用</p><p>！闭包的核心作用是：使变量可以驻留在内存，不被回收</p><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>结果输出为11，12，13</p><p>但是此时a为全局变量，如果别人不小心对a又重复赋值了，那么结果就不是我们预期的结果</p><p>那此时我们就不让a成为全局变量，把a的定义放在函数内部，让a成为函数的私有变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>此时就可以满足上面提到的函数的作用（第三条只要加个return就可以实现）</p><p>但是问题出现了：这次的结果三次都为11，这是因为函数在执行完一次后里面的变量就会被释放掉，下一次执行时又会重新对a进行赋值，所以结果一直为11</p><h4 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><p>条件：</p><ol><li>必须有个子函数 </li><li>子函数必须要调用父函数里面的变量</li></ol><p>实现自增的原因：</p><ol><li>执行的是f(),所以实际上执行的是子函数b，fn只在给f定义的时候执行了一次，所以后面let a &#x3D; 10也没有被执行</li><li>闭包函数内的变量可以保存下来</li></ol><p>我的疑惑：</p><ol><li>为什么要在下面重新定义一个f函数</li><li>为什么要加return       A ：1.因为要返回b函数？  2.最后f调用的是a变量，（如果外部想要使用闭包里面的变量，就要用return？）</li></ol><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>变量长时间驻留在内存，如果处理不当可能造成内存泄漏，所以用完可以手动清除</p><p>在最后加上下面的代码即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this（普通函数）————初版</title>
      <link href="/2023/12/03/this%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2023/12/03/this%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="this（普通函数"><a href="#this（普通函数" class="headerlink" title="this（普通函数)"></a>this（普通函数)</h2><h4 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h4><p>this———用于访问当前方法所属的对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">12</span>,</span><br><span class="line">    fn：<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>===obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>当前这个方法fn是属于obj，所以this就是obj，所以结果为true</p><p>这时用另一种写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">fn</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>===obj)</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>这种后添的写法结果也是完全一样</p><h4 id="this绑定方式"><a href="#this绑定方式" class="headerlink" title="this绑定方式"></a>this绑定方式</h4><p>this和函数的定义无关，和函数的调用有关，也可以说同一个函数的this可以有很多种值，这取决于怎么调用这个函数</p><p>1.直接调用——window || undefined  PS:在node环境里为global或者undefined</p><p>下面是直接调用函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>()</span><br></pre></td></tr></table></figure><p>结果为window，但这是个错误，因为show不属于任何对象，和this的定义有所冲突</p><p>在这里window相当于是一个兜底的角色，就是找不到this的时候，就用window来兜底</p><p>后面经过修改，如果加上了严格模式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br></pre></td></tr></table></figure><p>则结果为undefined</p><p>2.挂载在对象上，然后执行方法，那this就指向对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="property">fn</span>=show</span><br><span class="line">arr.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><p>此时输出的结果就是arr，因为此时show挂在了arr上面，属于对象arr，所以this输出的值就是arr</p><p>3.定时器——window</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(show,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在加了严格模式下输出结果仍为window</p><p>因为定时器本来就属于window，window来执行定时器，定时器来执行show，所以最终show是被window调用的</p><p>4.工具函数</p><p>使用call强制改变this的值   ps：apply </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">show.<span class="title function_">call</span>(<span class="number">12</span>)</span><br><span class="line">show.<span class="title function_">call</span>(<span class="string">&#x27;sdjlfhkajhf&#x27;</span>)<span class="comment">//这里要求变成个字符串</span></span><br><span class="line">show.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())<span class="comment">//这里要求变成个日期对象</span></span><br><span class="line">show.<span class="title function_">call</span>(&#123;<span class="attr">a</span>: <span class="number">12</span>&#125;)<span class="comment">//这里要求变成个json</span></span><br></pre></td></tr></table></figure><p>使用forEach</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的情况相当于第一种情况</p><p>函数并没有挂在arr上面，只是交给了forEach去调用</p><p>forEach实际上是</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="property">forEach</span>=<span class="keyword">function</span> (<span class="params">cb</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="variable language_">this</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="title function_">cb</span>(<span class="variable language_">this</span>[i])<span class="comment">//这里就是直接调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是forEach有第二个参数，这个参数就有绑定this的作用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,item)</span><br><span class="line">&#125;,<span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure><p>这里的用法就相当于是call的用法</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first</title>
      <link href="/2023/11/20/first/"/>
      <url>/2023/11/20/first/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/20/hello-world/"/>
      <url>/2023/11/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
